#!/bin/sh
# Ctrl-D to end
set -eu
: "${DEBUG:=}"
[ -n "$DEBUG" ] && set -x

usage="usage: $(basename $0) [-dsu] [-c | -b buddy]
-c: chat in current directory, expecting in and out files to exist
-b: chat with specified buddy
See sj(1) for explanation of options d, s, and u.
Environment variables:  all from sj(1) and style, color, note_time"

# Set configuration variable to "no" to disable feature
#
# style of incming message:  a style for tput e.g. bold, dim, blink, smul
# (underlined), rev (reverse), smso (standout)
: "${style:=no}"
# color of incoming message:  a color for tput setaf, e.g. 1-7
: "${color:=1}"
# number of milliseconds for the notify-send timeout
: "${note_time:=500}"

: "${SJ_DIR:=}"
: "${SJ_SERVER:=}"
: "${SJ_USER:=}"

current_dir=""  # initialize variables
buddy=""
while [ $# -gt 0 ]; do
	case "$1" in
		-d) [ -n "$2" ] && SJ_DIR="$2"; shift;;
		-s) [ -n "$2" ] && SJ_SERVER="$2"; shift;;
		-u) [ -n "$2" ] && SJ_USER="$2"; shift;;
		-b) [ -n "$2" ] && buddy="$2"; shift;;
		-c) current_dir=yes ;;
		*)  printf "$(basename $0): invalid option $1\n$usage\n"; exit 1;;
	esac
	shift
done

if [ -n "$current_dir" ]; then
	: # no need to change directory
else
	[ -n "$SJ_DIR" ] || { echo Directory is needed via -d or SJ_DIR; exit 1; }
	[ -n "$buddy" ] || { echo Buddy is needed via -b; exit 1; }
	cd "$SJ_DIR"/"$buddy" || { echo cannot cd to "$SJ_DIR"/"$buddy"; exit 1; }
fi
[ -e out ] || { echo out file required; exit 1; }
[ -p in ] || { echo in file required and must be a named pipe; exit 1; }
cat out  # show the conversation so far

# kill the background jobs
trap 'for child in $(ps -o pid,ppid ax | awk "{ if ( \$2 == $$ ) { print \$1 }}"); do
	ps $child >/dev/null && kill $child || true
done' HUP INT QUIT TERM EXIT
#trap "kill 0; exit" HUP INT QUIT TERM EXIT

export style color note_time SJ_USER SJ_SERVER
sjfs-monitor-outfile out &

## cat > in  # this works except that it inserts extra new lines
while read -r line
do
	printf '%s' "$line" | escape-xml >> in
done

kill 0  # kill the background jobs
