#!/usr/bin/env lua
require('strict')
local Px = require('posix')
local Cs = require('curses')

local SJ_DIR = os.getenv('SJ_DIR')
local SJ_SERVER = os.getenv('SJ_SERVER')
local SJ_USER = os.getenv('SJ_USER')
local current_dir = false
local buddy = nil

local skip = false
for i = 1, #arg do
	if skip then
		skip = false
	else
		if     arg[i] == '-c' then current_dir = true
		elseif arg[i] == '-d' then SJ_DIR = arg[i+1]; skip=true
		elseif arg[i] == '-s' then SJ_SERVER = arg[i+1]; skip=true
		elseif arg[i] == '-u' then SJ_USER = arg[i+1]; skip=true
		elseif arg[i] == '-b' then buddy = arg[i+1]; skip=true
		else 
			print(arg[0]..': invalid option: '..v)
			os.exit(false)
		end
	end
end

local chatdir = nil
if current_dir then
	chatdir = './'
else
	if (not SJ_DIR) or (SJ_DIR == '') then
		print('Directory is needed via -d or SJ_DIR')
		os.exit(false)
	elseif (not buddy) or (buddy == '') then
		print('Buddy is needed via -b')
		os.exit(false)
 	else
		chatdir = SJ_DIR .. '/' .. buddy .. '/'
	end
end

local outfilename = chatdir .. 'out'
local infilename = chatdir .. 'in'
if not os.execute('test -e ' .. outfilename) then
	print('out file required')
	print('attempted to open ' .. outfilename)
	os.exit(false)
elseif not os.execute('test -p ' .. infilename) then
	print('in file required and must be a named pipe')
	print('attempted to open ' .. infilename)
	os.exit(false)
end

local tail_out = assert(io.popen('tail -f -n0 ' .. outfilename, 'r'))
assert(tail_out:setvbuf('no'))
local tail_out_fd = Px.fileno(tail_out)

local stdin_fd = Px.fileno(io.stdin)

local fds = {
	[tail_out_fd] = { events = {IN=true} },
	[stdin_fd] = { events = {IN=true} }
}

local in_fifo = io.open(chatdir .. 'in', 'a')
assert(in_fifo:setvbuf('no'))

Cs.initscr()
--Cs.cbreak(false)
Cs.echo(false)
local stdscr = Cs.stdscr()
stdscr:clear()
stdscr:refresh()

local typing_lines = 2  -- size of the input window
local s_lines, s_cols = stdscr:getmaxyx()
local display_win = Cs.newwin(s_lines - typing_lines, s_cols, 0, 0)
local typing_win = Cs.newwin(typing_lines, s_cols, s_lines - typing_lines, 0)

typing_win:keypad(true)
typing_win:scrollok(true)
typing_win:clear()
typing_win:addstr('Type q then Enter to quit\n')
typing_win:refresh()

display_win:scrollok(true)
display_win:clear()
for ll in io.lines(outfilename) do
	display_win:addstr(ll .. '\n')
	display_win:refresh()
end
display_win:addstr('-------\n')
display_win:refresh()

local line = ''
local s = ''
while true do
	local poll_result = Px.poll(fds, -1)
	if poll_result == 0 then  -- timeout
		break
	elseif poll_result == 1 then
		if  fds[tail_out_fd].revents.IN then
			display_win:addstr(tail_out:read('*l') .. '\n')
			display_win:refresh()
			-- Cs.beep()
		elseif  fds[stdin_fd].revents.IN then
			local c = typing_win:getch()
			if c < 256 then
				s = string.char(c)
				typing_win:addstr(s)
				typing_win:refresh()
				display_win:addstr('i')
				display_win:refresh()
			else
				s = ''
				--typing_win:addstr('What kind of character is this?')
				--typing_win:refresh()
			end
			if s == '\n' then
				if line == 'q' then
					break
				end
				in_fifo:write(line)
				line = ''
				typing_win:clear()
				typing_win:addstr('Type q then Enter to quit\n')
				typing_win:refresh()
			else
				line = line .. s
			end
		else
			typing_win:addstr('What kind of event is this?')
			typing_win:refresh()
		end
	else
		display_win:addstr('Polling finished!')
		display_win:refresh()
		break
	end
end

in_fifo:flush()
in_fifo:close()
--tail_out:flush()  -- makes the program freeze
--tail_out:close()  -- makes the program freeze
Cs.endwin()

os.exit(true)
