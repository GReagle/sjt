#!/bin/ksh93
set -eu
: "${DEBUG:=}"
[ -n "$DEBUG" ] && set -x

usage="usage: $(basename $0) [-d <directory>]
Environment variables:  SJ_DIR, SJ_SERVER, SJ_USER"

# Set configuration variable to "no" to disable feature
#
# number of milliseconds for the notify-send timeout
: "${note_time:=no}"

: "${SJ_DIR:=}"
: "${SJ_SERVER:=}"
: "${SJ_USER:=}"

while [ $# -gt 0 ]; do
	case "$1" in
		-d) SJ_DIR="$2"; shift;;
		-s) SJ_SERVER="$2"; shift;;
		-u) SJ_USER="$2"; shift;;
		*)  printf "$(basename $0): invalid option $1\n$usage\n"; exit 1;;
	esac
	shift
done

[ -n "$SJ_DIR" ] || { echo Directory is needed via -d or SJ_DIR; exit 1; }
cd "$SJ_DIR" || { echo cannot cd to "$SJ_DIR"; exit 1; }

trap "kill 0; exit" HUP INT QUIT TERM EXIT  # kill all background jobs

outs1=`find . -name out | sort`
if [ -n "$outs1" ]; then
	for o in $outs1; do
		export note_time SJ_USER SJ_SERVER
		style=no color=no sjfs-monitor-outfile "$o" &
	done
fi

while true; do
	#sleep 5
	# The only purpose of entr here is to wait for a change in the current
	# directory; the first true is because entr needs a utility; the second
	# true is to prevent an error in the script since entr will return 2
	echo . | entr -pd true || true
	outs2=`find . -name out | sort`
	if [ "$outs1" != "$outs2" ] ; then
		new_outs=`comm -13 <(echo "$outs1") <(echo "$outs2")`  # <() requires ksh93
		for o in $new_outs; do
			notice="new chat from $(basename $(dirname $o))"
			printf "$notice\a\n"
			[ "$note_time" != no ] && notify-send -t "$note_time" "sjfs-monitor" "$notice"
			cat "$o"
			export note_time SJ_USER SJ_SERVER
			style=no color=no sjfs-monitor-outfile "$o" &
		done
		outs1="$outs2"
	fi
done
kill 0
